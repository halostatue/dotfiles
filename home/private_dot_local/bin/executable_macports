#!/usr/bin/env ruby
# frozen_string_literal: true

require "open3"
require "net/http"
require "pathname"
require "shellwords"
require "tempfile"
require "uri"
require "yaml"

CONFIG_FILE = File.expand_path("~/.config/macports.yml")
CONFIG = YAML.load_file(CONFIG_FILE, symbolize_names: true)

CONFIG[:ports].each_key do |port_name|
  CONFIG[:ports][port_name][:name] = port_name.to_s
end

EXPLICIT_VERSION = %r{^version[ \t]+(?<version>\S+)}m
GO_VERSION = %r{^go\.setup[ \t]+(?<repo>\S+)[ \t]+(?<version>\S+)(?:[ \t](?<prefix>\S+))?}m
GITHUB_VERSION = %r{^github\.setup[ \t]+(?<owner>\S+)[ \t]+(?<repo>\S+)[ \t]+(?<version>\S+)(?:[ \t]+(?<prefix>\S+))?}m

CARGO_CRATES = %r{
  ^cargo\.crates[ \t]*\\\r?\n
  (?:[ \t]*[^\r\n]*\\\r?\n)*
  [ \t]*[^\r\n]*(?:\r?\n|\z)
}mx

GO_VENDORS = %r{
  ^go\.vendors[ \t]*\\\r?\n
  (?:[ \t]*[^\r\n]*\\\r?\n)*
  [ \t]*[^\r\n]*(?:\r?\n|\z)
}mx

STACK = []
VERBOSE = !!(ARGV.delete("--verbose") || ARGV.delete("-v"))
UNSTABLE = !!(ARGV.delete("--unstable") || ARGV.delete("-U"))

def __safe(command) = command.is_a?(Array) ? command : Shellwords.split(command)

def __run(command, input: nil)
  Open3.popen3(*__safe(command)) do |stdin, stdout, stderr, wait|
    stdin.puts input if input
    stdin.close

    return {stdout: stdout.read.chomp, stderr: stderr.read.chomp, status: wait.value}
  end
end

def run(command, print: true, required: true, input: nil, verbose: false, description: nil)
  command = __safe(command)
  description ||= command.shelljoin
  puts "==> #{description}" if print

  __run(command, input: input) => {stdout:, stderr:, status:}

  puts stdout if (VERBOSE || verbose) && !stdout.empty?

  return true if status.success?

  warn stderr unless stderr.empty?
  if required
    halt "Command failed: #{command.shelljoin}", status: status.exitstatus
  end

  false
end

def sudo(command, print: true)
  command = __safe(command).unshift("sudo")
  run(command, required: true, print: print)
end

def shell_run(command, ...) = run(%W[sh -c #{__safe(command).shelljoin}], ...)

def capture_or_false(command)
  __run(command) => {stdout:, stderr:, status:}

  status.success? ? stdout : false
end

def capture_or(command, message)
  __run(command) => {stdout:, stderr:, status:}

  return stdout if status.success?

  warn stderr unless stderr.empty?
  halt message, status: status.exitstatus
end

def capture!(command) = capture_or(command, "Error capturing #{__safe(command).shelljoin}")

def halt(message, status: 1)
  warn message
  exit status
end

def warn(message) = Kernel.warn "macports #{STACK.last}: #{message}"

public_tree = CONFIG.dig(:roots, :public) || capture_or(
  %w[zoxide query macports-ports],
  "Cannot find public macports tree with zoxide for #{port[:name]}."
)

private_tree = CONFIG.dig(:roots, :private) || "~/ports"

PUBLIC_TREE = File.expand_path(public_tree)
PRIVATE_TREE = File.expand_path(private_tree)

halt "#{PUBLIC_TREE} does not exist" unless File.directory?(PUBLIC_TREE)
halt "#{PRIVATE_TREE} does not exist" unless File.directory?(PRIVATE_TREE)

def context(name)
  STACK.push(name.to_s.tr("_", "-"))
  yield
ensure
  STACK.pop
end

def git_main_branch = File.basename(Dir[".git/refs/heads/{main,master}"].first || "main")

def xcode_version
  __run(%w[xcodebuild -version]) => {stdout:, status:}

  return nil unless status.success?

  xcode, build_version = stdout.chomp.split($/)
  "#{xcode} #{build_version.shellsplit.last}"
end

def clt_version
  __run(%w[pkgutil --pkg-info=com.apple.pkg.CLTools_Executables]) => {stdout:, status:}

  if stdout =~ /version: (.+)/
    "Command Line Tools #{$1}"
  else
    halt "Cannot resolve Command Line Tools version from: #{stdout.inspect}"
  end
end

def tested_on
  context(__callee__) do
    product_version = `sw_vers -productVersion`.chomp
    build_version = `sw_vers -buildVersion`.chomp
    hardware = `uname -m`.chomp
    build_tools = xcode_version || clt_version

    halt "Cannot find Xcode or Xcode Command Line Tools." if build_tools.nil?

    <<~TESTED_ON
      macOS #{product_version} #{build_version} #{hardware}
      #{build_tools}
    TESTED_ON
  end
end

def run_test_script(port, verbose: false)
  Tempfile.create(["macports-test-"], binmode: false) do |f|
    f.write(port[:test_script])
    f.fsync
    f.close
    File.chmod(0o755, f.path)
    run(f.path, verbose: verbose, description: "Test script for #{port[:name]}")
  end
end

def get_trac_patch(url, path = nil)
  halt "trac-patch URL cannot be empty." unless url
  halt "trac-patch URL must begin with https://" unless url.start_with?("https://")

  path ||= "."
  path = File.join(path, File.basename(URI(url).path))

  # Use curl with --fail and --silent --show-error so network failures are surfaced.
  run %W[curl --fail --location --silent --show-error #{url}?format=raw --create-dirs -o #{path}]

  path
end

def trac_patch(args)
  context(__callee__) do
    patch = []

    while args.first&.start_with?("-")
      break if args.first == "--"
      patch << args.shift
    end

    patch = %w[--strip 0] if patch.empty?
    patch.unshift("patch")
    url, dir = *args

    path = get_trac_patch(url, dir)

    run(patch, input: File.read(path))
  end
end

def update_port(port_name, force, target_version)
  context(__callee__) do
    do_update_port(port_name, force, target_version)
  end
end

def set_port_type(port)
  port[:file] = File.join(port[:path], "Portfile")

  begin
    portfile = port[:portfile] = File.read(port[:file])
  rescue Errno::ENOENT
    halt "Portfile not found at #{port[:file]}"
  end

  port[:golang] = portfile.match?(%r{^PortGroup\s+golang\s+1\.0})
  port[:github] = portfile.match?(%r{^PortGroup\s+github\s+1\.0})
  port[:needs_cargo_crates] = portfile.match?(%r{^cargo\.crates})
  port[:needs_go_vendors] = portfile.match?(%r{^go\.vendors})
end

def check_port_path(port, tree)
  return unless port[:category]

  candidate = File.join(tree, port[:category], port[:name])

  File.exist?(File.join(candidate, "Portfile")) && candidate
end

def do_resolve_port_path(port)
  case [check_port_path(port, PUBLIC_TREE), check_port_path(port, PRIVATE_TREE)]
  in [path, false]
    [:public, PUBLIC_TREE, path]
  in [false, path]
    [:private, PRIVATE_TREE, path]
  in [false, false]
    [:error, :error, :error]
  in [String, String => path]
    [:both, PRIVATE_TREE, path]
  end
end

def resolve_port_path(port)
  result, tree, path = do_resolve_port_path(port)

  if result == :error
    halt "#{port[:category]}/#{port[:name]} not found in either the public or private trees."
  end

  if result == :both
    warn "#{port[:category]}/#{port[:name]} found in both public and private trees."
    warn "  Using the private tree instance. Press Ctrl-C to cancel or ENTER to continue"
    gets

    result = :private
  end

  port[:private] = result == :private
  port[:path] = path
  port[:root] = tree
end

def handle_unknown_port(port)
  candidate = [
    Dir[File.join(PUBLIC_TREE, "*", port[:name], "Portfile")].first,
    Dir[File.join(PRIVATE_TREE, "*", port[:name], "Portfile")].first
  ].compact.first

  halt "Unknown port #{port[:name]}." unless candidate

  port[:category] = File.basename(File.dirname(candidate, 2))

  warn "port #{port[:name]}: No update procedure in #{CONFIG_FILE}."
  warn "port #{port[:name]}: Guessed root category is #{port[:category]}."

  puts "Enter test command for port #{port[:name]} to continue:"
  port[:test] = gets.to_s.chomp
  halt "No test procedure for #{port[:name]} provided." if port[:test].empty?
end

def get_updated_portfile(port, target_version)
  seaport = %W[seaport clip #{port[:name]}]
  seaport << "--bump" << target_version if target_version
  run seaport

  port[:update] = capture_or(
    %w[pbpaste],
    "pbpaste failed: ensure the updated Portfile is on the clipboard"
  )
end

def set_port_version(port)
  update = port[:update]

  case update.match(EXPLICIT_VERSION)
  in {version: version}
    port[:version] = version
  in nil
  end

  if port[:golang]
    case update.match(GO_VERSION)
    in {repo: repo, version: version, prefix: prefix}
      port[:version] = version
      port[:go_package] = repo
      port[:full_version] = "#{prefix}#{version}"
      repo.gsub!(%r{github.com/}, "")
      port[:tag_url] = "https://raw.githubusercontent.com/#{repo}/refs/tags/#{port[:full_version]}/"
    in nil
    end
  end

  if port[:github]
    case update.match(GITHUB_VERSION)
    in {owner: owner, repo: repo, version: version, prefix: prefix}
      port[:version] = version
      port[:full_version] = "#{prefix}#{version}"
      port[:tag_url] = "https://raw.githubusercontent.com/#{owner}/#{repo}/refs/tags/#{port[:full_version]}/"
    in nil
    end
  end

  halt "Cannot determine next target version for #{port[:name]}" unless port[:version]
  # Validate port name and version format constraints:
  unless /\A[-a-z0-9_]+\z/.match?(port[:name])
    halt "Invalid port name: #{port[:name]} (allowed: [-a-z0-9_])"
  end
  unless /\A[0-9A-Za-z.\-+_]+\z/.match?(port[:version])
    halt "Suspicious version format: #{port[:version]}"
  end
end

def check_merge(port)
  log = begin
    capture!(%W[git log --grep \\b#{port[:name]}.\\+#{port[:version]} --since 7.days.ago])
  rescue
    ""
  end
  unless log.empty?
    warn "port #{port[:name]}: #{port[:version]} has already been merged"
    Kernel.warn log
    exit 1
  end
end

def check_prs(port)
  search = "(#{port[:name]} AND #{port[:version]}) in:title"
  jq = "(. | length) > 0"

  result = begin
    capture!(%W[gh pr list --search #{search} --json number --jq #{jq}])
  rescue
    "false"
  end
  if result.strip == "true"
    warn "#{port[:name]}: #{port[:version]} already has an open PR."
    search2 = "#{port[:name]} in:title"
    jq2 = 'map("#\(.number) \(.title)") | .[]'
    run %W[gh pr list --search #{search2} --json number,title --jq #{jq2}]
    exit 1
  end
end

def apply_crate2port(port)
  return unless port[:needs_cargo_crates]

  port[:update].gsub!(CARGO_CRATES, "")

  if port[:cargo_lock] == "github" && port[:tag_url]
    uri = URI.join(port[:tag_url], "Cargo.lock")
    res = Net::HTTP.start(uri.host, uri.port, use_ssl: uri.scheme == "https", read_timeout: 15, open_timeout: 5) do |http|
      http.get(uri.request_uri)
    end
    unless res.is_a?(Net::HTTPSuccess)
      halt "Failed to fetch Cargo.lock from #{uri} (#{res.code})"
    end

    IO.popen(%w[crate2port -], "r+") do |pipe|
      pipe.puts res.body
      pipe.close_write
      port[:update] << "\n" << pipe.read
    end
  else
    crate = port[:crate] || port[:name]
    port[:update] << "\n" << capture!(%W[crate2port #{crate}@#{port[:version]}])
  end
end

def apply_go2port(port)
  return unless port[:needs_go_vendors]

  port[:update].gsub!(GO_VENDORS, "")
  go2port = %W[go2port #{port[:go_package]} #{port[:full_version]}]
  port[:update] << "\n" << capture!(go2port)
end

def prepare_pr(port, branch)
  run %W[port lint]
  sudo %W[port clean]

  Array(port.fetch(:variants, [])).each do |variant|
    sudo %W[port build -N +#{variant}]
    sudo %W[port clean]
  end

  sudo %W[port install -N]

  if port[:test]
    # port[:test] is required to be a shell command; allow pipes, so run via shell.
    shell_run port[:test]
  elsif port[:test_script]
    run_test_script(port)
  elsif port[:private]
    return
  else
    halt "#{port[:name]}: Cannot prepare PR for public port without a port test."
  end

  commit_msg = capture!(%W[git log #{branch}.. --format=%B])

  port[:pr_body] =
    CONFIG[:template]
      .gsub(/\{\{\s*description\s*\}\}/, commit_msg)
      .gsub(/\{\{\s*tested_on\s*\}\}/, tested_on)

  if UNSTABLE || !port[:stable]
    puts port[:commit_message]
    puts port[:pr_body]
  end
end

def create_pr(port, confirm: false)
  # Do not auto-skip confirmation for non-stable ports.
  return if port[:stable] && confirm && !UNSTABLE

  gh_pr_create = %W[gh pr create --fill --body-file -]
  gh_pr_create << "--dry-run" if confirm

  run(gh_pr_create, input: port[:pr_body], verbose: confirm)

  if confirm
    puts "Press Ctrl-C to cancel or ENTER to continue"
    gets
  end
end

def do_update_port(port_name, force, target_version)
  port = CONFIG[:ports][port_name.to_sym] || {}
  port[:name] ||= port_name

  if port[:cargo_unstable] && !force
    halt "#{port[:name]} cannot be updated automatically because of Cargo.lock instability."
  end

  handle_unknown_port(port) if port[:category].nil?

  resolve_port_path(port)

  sudo %W[port sync]

  Dir.chdir(port[:root]) do
    branch = git_main_branch
    run %W[git switch #{branch}]
    run %W[git fetch --all]
    run %W[git pull --rebase]

    set_port_type(port)
    get_updated_portfile(port, target_version)
    set_port_version(port)

    check_merge(port)
    check_prs(port)

    run(%W[port echo requested and name:#{port[:name]}])
    port[:requested] = capture!(%W[port echo requested and name:#{port[:name]}])

    Dir.chdir(port[:path]) do
      pr_branch = "#{port[:name]}-#{port[:version]}"
      run %W[git switch --create #{pr_branch} #{branch}] unless port[:private]

      apply_crate2port(port)
      apply_go2port(port)

      File.write(port[:file], port[:update])

      run %W[git add #{port[:file]}]

      if port[:private]
        Dir.chdir(port[:root]) do
          run %W[portindex]
          run %W[git add PortIndex PortIndex.quick]
        end
      end

      port[:commit_message] = "#{port[:name]}: Update to #{port[:version]}"

      run %W[git commit -m #{port[:commit_message]}]

      prepare_pr(port, branch)

      if port[:private]
        run %W[git push]
      else
        if !port[:pr_body] || port[:pr_body].empty?
          halt "port #{port[:name]}: Error generating pull request body"
        end

        run %W[git push origin #{pr_branch} --set-upstream]

        create_pr(port, confirm: true)
        create_pr(port)

        run %W[git switch #{branch}]
      end
    end

    sudo %W[port uninstall #{port[:name]}] if port[:requested].nil? || port[:requested].empty?
  end
end

def group_ports
  public_ports = []
  private_ports = []
  both = []

  CONFIG[:ports].each_value do
    case do_resolve_port_path(it)
    in [:public, _, _]
      public_ports << it[:name]
    in [:private, _, _]
      private_ports << it[:name]
    in [:both, _, _]
      both << it[:name]
      private_ports << it[:name]
      public_ports << it[:name]
    else
      nil
    end
  end

  {both:, public_ports:, private_ports:}
end

def print_livecheck(name)
  __run(%W[port livecheck #{name}]) => {status:, stderr:, stdout:}

  output =
    if !status.success?
      "error on livecheck: #{stderr.chomp}"
    elsif stdout.chomp.empty?
      "no updates"
    else
      stdout.chomp.sub(%r{#{name} seems to have been updated }, "").gsub(%r{[()]}, "")
    end

  puts "#{name}: #{output}"
end

def print_ports(&block)
  group_ports => {public_ports:, private_ports:}

  puts "==> Public Ports" unless public_ports.empty?
  public_ports.each(&block)

  puts "\n==> Private Ports" unless private_ports.empty?
  private_ports.each(&block)
end

def livecheck = print_ports { print_livecheck(it) }

def check_requested(args)
  if args.empty?
    print_ports do
      __run(%W[port echo requested and name:#{it}]) => {stdout:}

      puts "#{it}: #{stdout.chomp.empty? ? "unrequested" : "requested"}"
    end
  else
    args.each do
      __run(%W[port echo requested and name:#{it}]) => {stdout:}

      puts "#{it}: #{stdout.chomp.empty? ? "unrequested" : "requested"}"
    end
  end
end

def run_port_test(port_name)
  port = CONFIG[:ports][port_name.to_sym] || {}

  halt "#{port_name} does not have a defined test." if !port[:test] && !port[:test_script]

  if port[:test]
    # port[:test] is required to be a shell command; allow pipes, so run via shell.
    shell_run port[:test]
  elsif port[:test_script]
    run_test_script(port, verbose: true)
  end
end

# CLI parsing (minimal)
# Remove verbose arg from ARGV first if present
ARGV.reject! { |a| a == "--verbose" || a == "-v" }

command = ARGV.first
ARGV.shift

case command
when "trac-patch", "trac_patch"
  trac_patch(ARGV)
when "xcode", "xcode-version", "xcode_version"
  puts xcode_version
when "cli", "cli-version", "cli_version"
  puts clt_version
when "tested-on", "tested_on"
  puts tested_on
when "livecheck"
  livecheck
when "update", "update-port", "update_port"
  name = nil
  force = false
  target_version = nil

  while ARGV.first
    case ARGV.first
    when "--force", "-F"
      force = true
    when "--version"
      ARGV.shift
      target_version = ARGV.first
    else
      name = ARGV.first
    end
    ARGV.shift
  end

  halt "No port name provided for #{command}." unless name

  # Validate port name early
  unless /\A[-a-zA-Z0-9_.]+\z/.match?(name)
    halt "Invalid port name: #{name} (allowed: [-a-zA-Z0-9_.])"
  end

  update_port(name, force, target_version)
when "test"
  run_port_test(ARGV.first)
when "requested"
  check_requested(ARGV)
when %(show)
  print_ports { puts it }
else
  warn "Unknown or missing command"
  puts "Usage: #{File.basename($PROGRAM_NAME)} [--verbose] update <portname> [--force] [--version <ver>]"
end
